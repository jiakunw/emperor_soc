// formal_axi_tb.sv
`timescale 1ns / 1ps

// 16'h4600_01XX is GPIO's address, only use that
module v_axi_mmio_controller
(
    input logic aclk, arst_n,
    // AXI slave interface with main Bus
    // write
    input logic [31:0] S_AXI_awaddr,
    input logic [2:0] S_AXI_awprot,
    input logic S_AXI_awvalid,
    input logic S_AXI_awready,
    input logic [31:0] S_AXI_wdata,
    input logic [3:0] S_AXI_wstrb,
    input logic S_AXI_wvalid,
    input logic S_AXI_wready,
    input logic [1:0] S_AXI_bresp,
    input logic S_AXI_bvalid,
    input logic S_AXI_bready,
    // read
    input logic [31:0] S_AXI_araddr,
    input logic [2:0] S_AXI_arprot,
    input logic S_AXI_arvalid,
    input logic S_AXI_arready,
    input logic [31:0] S_AXI_rdata,
    input logic [1:0] S_AXI_rresp,
    input logic S_AXI_rvalid,
    input logic S_AXI_rready,
    // gpio external
    input logic [8:0] in_ports,
    input logic [8:0] out_ports,
    // uart external
    input logic rx,
    input logic tx,
    // i2c external
    input tri scl,
    input tri sda,
    // bus internal
    input logic [2:0] r_state
);
    //arst_n signal
    logic arst_n_signal = arst_n;

    // handshake signals
    // write
    logic write_addr_handshake;
    logic write_data_handshake;
    logic write_response_handshake;
    // read
    logic read_addr_handshake;
    logic read_response_handshake;

    // write handshakes
    assign write_addr_handshake = S_AXI_awvalid & S_AXI_awready;
    assign write_data_handshake = S_AXI_wvalid & S_AXI_wready;
    assign write_response_handshake = S_AXI_bvalid & S_AXI_bready;
    // read handshakes
    assign read_addr_handshake = S_AXI_arvalid & S_AXI_arready;
    assign read_response_handshake = S_AXI_rvalid & S_AXI_rready;

    // other signals
    // logic [7:0] slot_addr;

    // always_ff @(posedge aclk) begin
    //     if (S_AXI_awvalid)
    //         slot_addr <= S_AXI_awaddr[15:8];
    //     else if (S_AXI_arvalid)
    //         slot_addr <= S_AXI_awaddr[15:8];
    // end

    /*************************************** sequences ****************************************/

    sequence s_in_transaction;
	(r_state != INIT)[*0:$];
    endsequence

    sequence s_no_write;
	(r_state != WRITE_1)[*0:$];
    endsequence
    
    /*********************************** assumed properties ***********************************/


    // reset
    property p_reset_eventually_release;
	@(posedge aclk)
	    1'b1 |-> ##[0:$] arst_n;
    endproperty

    property p_reset_eventually_done;
        @(posedge aclk)
	    (!arst_n) |=> arst_n;
    endproperty

    // write
    property p_gpio_waddr;
        @(posedge aclk) 
            S_AXI_awaddr[31:8] == 24'h4600_01 && S_AXI_awaddr % 4 == 0;
    endproperty

    property p_addr_write_read_initiation;
	@(posedge aclk) 
	    (r_state == INIT) |-> ##[0:$] (S_AXI_awvalid ^ S_AXI_arvalid);
    endproperty

    property p_awvalid_until_aw_hs;
      @(posedge aclk)
        // we’re in INIT and AW is the active one
        (S_AXI_awvalid && !S_AXI_awready)
          |=> (S_AXI_awvalid || write_addr_handshake);
    endproperty

    property p_no_read_when_write;
	@(posedge aclk)
	    S_AXI_awvalid |-> !S_AXI_arvalid;
    endproperty

    property p_addr_write_stable;
        @(posedge aclk) 
            (S_AXI_awvalid && $past(S_AXI_awvalid)) |-> $stable(S_AXI_awaddr);
    endproperty

    property p_data_write_initiation;
        @(posedge aclk) 
            write_addr_handshake |-> ##[0:$] S_AXI_wvalid;
    endproperty

    property p_data_wvalid_before_handshake;
	@(posedge aclk)
	    S_AXI_wvalid && !S_AXI_wready |=> S_AXI_wvalid || write_data_handshake;
    endproperty

    property p_secure_write_access;
        @(posedge aclk) 
            (S_AXI_awprot == 2'd0);
    endproperty

    property p_deassert_awvalid_after_handshake;
        @(posedge aclk) 
            (write_addr_handshake) |=>
                (!S_AXI_awvalid) throughout (s_in_transaction);
    endproperty

    property p_data_write_stable;
        @(posedge aclk) 
            (S_AXI_wvalid && $past(S_AXI_wvalid)) |-> 
                $stable(S_AXI_wdata);
    endproperty

    property p_deassert_wvalid_after_handshake;
        @(posedge aclk) 
            (write_data_handshake) |=> 
		(!S_AXI_wvalid) throughout (s_in_transaction);
    endproperty

    property p_no_ilegal_bready;
	@(posedge aclk)
	    (r_state == INIT) || (r_state == WRITE_1) |-> !S_AXI_bready;
    endproperty

    property p_bready_after_handshake;
	@(posedge aclk)
	    write_data_handshake |=> ##[0:2] S_AXI_bready;
    endproperty

    property p_bready_until_write_response_handshake;
	@(posedge aclk)
	    (r_state == WRITE_1 || r_state == WRITE_RESP) && S_AXI_bready && !S_AXI_bvalid |=>
		(S_AXI_bready || write_response_handshake);
    endproperty

    property p_bready_deasserts_after_handshake;
	@(posedge aclk)
	    write_response_handshake |=> (!write_response_handshake) throughout (r_state != INIT);
    endproperty


    // read
    property p_gpio_raddr;
        @(posedge aclk) 
            S_AXI_araddr[31:8] == 24'h4600_01 && S_AXI_araddr % 4 == 0;
    endproperty

    property p_addr_read_initiation;
	@(posedge aclk)
            (r_state == INIT) |-> ##[0:$] S_AXI_arvalid;
    endproperty

    property p_arvalid_until_ar_hs;
        @(posedge aclk)
        // we’re in INIT and AR is the active one
        (S_AXI_arvalid && !S_AXI_arready)
          |=> (S_AXI_arvalid || read_addr_handshake);
    endproperty

    property p_no_write_when_read;
	@(posedge aclk)
	    S_AXI_arvalid |-> !S_AXI_awvalid;
    endproperty

    property p_addr_read_stable;
        @(posedge aclk) 
            (S_AXI_arvalid && $past(S_AXI_arvalid)) |-> 
                $stable(S_AXI_araddr);
    endproperty

    property p_deassert_arvalid_after_handshake;
        @(posedge aclk) 
            (read_addr_handshake) |=>
     		(!S_AXI_arvalid) throughout (s_in_transaction);
    endproperty

    property p_no_illegal_rready;
	@(posedge aclk)
	    (r_state == INIT) |-> !S_AXI_rready;
    endproperty

    property p_rready_initiation;
	@(posedge aclk)
	    (read_addr_handshake) |=> ##[0:$]S_AXI_rready;
    endproperty

    property p_rready_stable;
	@(posedge aclk)
	    S_AXI_rready && !S_AXI_rvalid |=> S_AXI_rready;
    endproperty

    // slave devices
    property p_gpio_in_ports;
        @(posedge aclk) 
            in_ports == 9'd0;
    endproperty

    property p_uart_rx;
        @(posedge aclk) 
            rx == 1'b0;
    endproperty

    property p_i2c_sda;
        @(posedge aclk) 
            sda == 1'b0;
    endproperty

    /*********************************** assumed assertions ***********************************/


    // reset
    // asm_reset_eventually_release: assume property (p_reset_eventually_release);
    // asm_reset_eventually_done: assume property (p_reset_eventually_done);
    

    // write
    asm_gpio_waddr: assume property (p_gpio_waddr);
    asm_addr_write_stable: assume property(p_addr_write_stable);
    asm_addr_write_read_initiation: assume property(p_addr_write_read_initiation);
    asm_awvalid_until_aw_hs: assume property(p_awvalid_until_aw_hs);
    asm_arvalid_until_ar_hs: assume property(p_arvalid_until_ar_hs);
    asm_data_data_initiation: assume property(p_data_write_initiation);
    asm_secure_write_access: assume property(p_secure_write_access);
    asm_data_wvalid_before_handshake: assume property(p_data_wvalid_before_handshake);
    asm_deassert_awvalid_after_handshake: assume property(p_deassert_awvalid_after_handshake);
    asm_data_write_stable: assume property(p_data_write_stable);
    asm_deassert_wvalid_after_handshake: assume property(p_deassert_wvalid_after_handshake);
    asm_no_read_when_write: assume property(p_no_read_when_write);
    asm_bready_after_handshake: assume property(p_bready_after_handshake);
    asm_bready_until_write_response_handshake: assume property(p_bready_until_write_response_handshake);
    asm_bready_deasserts_after_handshake: assume property(p_bready_deasserts_after_handshake);
    asm_no_ilegal_bready: assume property(p_no_ilegal_bready);

    // read
    asm_gpio_raddr: assume property(p_gpio_raddr);
    asm_addr_read_initiation: assume property(p_addr_read_initiation);
    asm_addr_read_stable: assume property(p_addr_read_stable);
    asm_deassert_arvalid_after_handshake: assume property(p_deassert_arvalid_after_handshake);
    asm_no_write_when_read: assume property(p_no_write_when_read);
    asm_no_illegal_rready: assume property(p_no_illegal_rready);
    asm_rready_initiation: assume property(p_rready_initiation);
    asm_rready_stable: assume property(p_rready_stable);

    // device
    asm_gpio_in_ports: assume property(p_gpio_in_ports);
    asm_uart_rx: assume property(p_uart_rx);
    asm_i2c_sda: assume property(p_i2c_sda);

    /*********************************** coverage properties ***********************************/
    property p_cover_arst_n_signal;
    	@(posedge aclk)
	     arst_n;
    endproperty

    // fsm states
    property p_cover_fsm_init;
        @(posedge aclk)
            (r_state==INIT);
    endproperty

    property p_cover_INIT_and_write_handshake;
       @(posedge aclk) disable iff (!arst_n)
           (r_state == INIT) && write_addr_handshake;
    endproperty

    property p_cover_fsm_write_1;
        @(posedge aclk) disable iff (!arst_n)
            (r_state==WRITE_1);
    endproperty

    property p_cover_fsm_write_resp;
        @(posedge aclk) 
            (r_state==WRITE_RESP);
    endproperty

    property p_cover_fsm_read_1;
        @(posedge aclk)
            (r_state==READ_1);
    endproperty

    property p_cover_fsm_read_resp;
       @(posedge aclk)
            (r_state==READ_RESP);
    endproperty

    // write
    property p_cover_handshake_write_address;
        @(posedge aclk) 
            (write_addr_handshake);
    endproperty

    property p_cover_wvalid;
	@(posedge aclk)
	    S_AXI_wvalid;
    endproperty

    property p_cover_handshake_write;
        @(posedge aclk) 
            (write_data_handshake);
    endproperty

    property p_cover_handshake_write_response;
        @(posedge aclk) 
            (write_response_handshake);
    endproperty 

    property p_cover_bresp_okay;
        @(posedge aclk)
            (S_AXI_bresp == AXI_RESP_OKAY);
    endproperty

    property p_cover_bresp_slverr;
        @(posedge aclk) 
            (S_AXI_bresp == AXI_RESP_SLVERR);
    endproperty

    property p_cover_bresp_decerr;
        @(posedge aclk)
            (S_AXI_bresp == AXI_RESP_DECERR);
    endproperty

    // read
    property p_cover_handshake_read_address;
    @(posedge aclk) 
        (read_addr_handshake);
    endproperty

    property p_cover_handshake_read;
        @(posedge aclk) 
            (read_response_handshake);
    endproperty

    property p_cover_rresp_okay;
        @(posedge aclk) 
            (S_AXI_rresp == AXI_RESP_OKAY);
    endproperty

    property p_cover_rresp_slverr;
        @(posedge aclk)
            (S_AXI_rresp == AXI_RESP_SLVERR);
    endproperty

    property p_cover_rresp_decerr;
        @(posedge aclk) 
            (S_AXI_rresp == AXI_RESP_DECERR);
    endproperty


    /*********************************** coverage assertions ***********************************/

    c_cover_arst_n_signal: cover property(p_cover_arst_n_signal);
    c_cover_INIT_and_write_handshake: cover property(p_cover_INIT_and_write_handshake);

    // COV_init_to_read1: cover property (@(posedge aclk)
  
    //   (r_state==INIT && read_addr_handshake) ##1 (r_state==READ_1)
    // );

    // fsm
    c_cover_fsm_init: cover property(p_cover_fsm_init);
    c_cover_fsm_write_1: cover property(p_cover_fsm_write_1);
    c_cover_fsm_write_resp: cover property(p_cover_fsm_write_resp);
    c_cover_fsm_read_1: cover property(p_cover_fsm_read_1);
    c_cover_fsm_read_resp: cover property(p_cover_fsm_read_resp);

    // write
    c_cover_wvalid: cover property(p_cover_wvalid);
    c_cover_handshake_write_address: cover property(p_cover_handshake_write_address);
    c_cover_handshake_write: cover property(p_cover_handshake_write);
    c_cover_handshake_write_response: cover property(p_cover_handshake_write_response);
    c_cover_bresp_okay: cover property(p_cover_bresp_okay);
    c_cover_bresp_slverr: cover property(p_cover_bresp_slverr);
    c_cover_bresp_decerr: cover property(p_cover_bresp_decerr);

    // read
    c_cover_handshake_read_address: cover property(p_cover_handshake_read_address);
    c_cover_handshake_read: cover property(p_cover_handshake_read);
    c_cover_rresp_okay: cover property(p_cover_rresp_okay);
    c_cover_rresp_slverr: cover property(p_cover_rresp_slverr);
    c_cover_rresp_decerr: cover property(p_cover_rresp_decerr);

    // slave device register access
    c_rd_addr_00: cover property (@(posedge aclk) S_AXI_araddr == 32'h4600_0100);
    c_wr_addr_00: cover property (@(posedge aclk) S_AXI_awaddr == 32'h4600_0100);
    c_rd_addr_04: cover property (@(posedge aclk) S_AXI_araddr == 32'h4600_0104);
    c_wr_addr_04: cover property (@(posedge aclk) S_AXI_awaddr == 32'h4600_0104);
    c_rd_addr_08: cover property (@(posedge aclk) S_AXI_araddr == 32'h4600_0108);
    c_wr_addr_08: cover property (@(posedge aclk) S_AXI_awaddr == 32'h4600_0108);
    c_rd_addr_0c: cover property (@(posedge aclk) S_AXI_araddr == 32'h4600_010c);
    c_wr_addr_0c: cover property (@(posedge aclk) S_AXI_awaddr == 32'h4600_010c);
    c_rd_addr_10: cover property (@(posedge aclk) S_AXI_araddr == 32'h4600_0110);
    c_wr_addr_10: cover property (@(posedge aclk) S_AXI_awaddr == 32'h4600_0110);

    
    /*********************************** assertion properties ***********************************/


    ///////////////////////
    ////              ////
    ////    safety   ////
    ////            ////
    ///////////////////

    // write
    property p_state_IDLE_to_WRITE_1;
	@(posedge aclk) (r_state == INIT && write_addr_handshake) |=> r_state == WRITE_1;
    endproperty

    property p_state_WRITE_1_to_WRITE_RESP;
        @(posedge aclk) (r_state == WRITE_1 && write_data_handshake) |=> (r_state == WRITE_RESP);
    endproperty

    property p_state_WRITE_RESP_to_IDLE;
        @(posedge aclk) (r_state == WRITE_RESP && S_AXI_bready) |=> (r_state == INIT);
    endproperty

    property p_state_WRITE_1_no_IDLE_READ_1_READ_RESP;
        @(posedge aclk) r_state == WRITE_1 |=> !(r_state == INIT) && !(r_state == READ_1) && !(r_state == READ_RESP);
    endproperty

    property p_state_WRIRE_RESP_no_WRITE_1_READ_1_READ_RESP;
	@(posedge aclk) r_state == WRITE_RESP |=> !(r_state == WRITE_1) && !(r_state == READ_1) && !(r_state == READ_RESP);
    endproperty

    property p_state_INIT_to_WRITE_1;
    	@(posedge aclk) ((r_state == INIT) && write_addr_handshake) |=> r_state == WRITE_1;
    endproperty

    property p_slave_write_response_stable;
	@(posedge aclk) S_AXI_bvalid && $past(S_AXI_bvalid) |->
	    $stable(S_AXI_bresp);
    endproperty

    // read
    property p_state_READ_1_no_IDLE_WRITE_1_WRITE_RESP;
	@(posedge aclk) r_state == READ_1 |=> !(r_state == WRITE_1) && !(r_state == INIT) && !(r_state == WRITE_RESP); 
    endproperty

    property p_state_READ_RESP_to_IDLE;
        @(posedge aclk) (r_state == READ_RESP && read_response_handshake) |=> (r_state == INIT);
    endproperty

    property p_state_READ_RESP_no_READ_1_WRITE_1_WRITE_RESP;
        @(posedge aclk) r_state == READ_RESP |=> !(r_state == WRITE_1) && !(r_state == READ_1) && !(r_state == WRITE_RESP);
    endproperty

    property p_state_INIT_to_READ_1;
        @(posedge aclk) ((r_state == INIT) && read_addr_handshake) |=> r_state == READ_1;
    endproperty

    /////////////////////////
    ////                ////
    ////    liveness   ////
    ////              ////
    /////////////////////

    // write
    property p_write_addr_handshake;
	@(posedge aclk) (r_state == INIT) && S_AXI_awvalid |-> ##[0:$]write_addr_handshake;
    endproperty

    property p_write_data_handshake;
        @(posedge aclk) write_addr_handshake |-> ##[0:$]write_data_handshake; 
    endproperty

    property p_slave_write_response_assertion;
        @(posedge aclk) write_data_handshake |-> ##[0:$]S_AXI_bvalid;
    endproperty

    property p_write_response_handshake;
        @(posedge aclk) write_data_handshake |-> ##[0:$]write_response_handshake; 
    endproperty

    // read
    property p_read_addr_handshake;
	@(posedge aclk) (r_state == INIT) && S_AXI_arvalid |-> ##[0:$]read_addr_handshake;
    endproperty

    property p_state_READ_1_to_READ_RESP;
    @(posedge aclk) (r_state == READ_1) |=> ##[0:$](r_state == READ_RESP) ;
    endproperty

    property p_read_response_handshake;
	@(posedge aclk) read_addr_handshake |-> ##[0:$] read_response_handshake;
    endproperty

    property p_slave_read_response_stable;
	@(posedge aclk) S_AXI_rvalid && $past(S_AXI_rvalid) |->
	    $stable(S_AXI_rresp);
    endproperty

    property p_slave_read_data_stable;
	@(posedge aclk) S_AXI_rvalid && $past(S_AXI_rvalid) |->
	    $stable(S_AXI_rdata);
    endproperty

    property p_slave_read_response_assertion;
        @(posedge aclk) write_addr_handshake |-> ##[0:$]S_AXI_rvalid;
    endproperty


    /*********************************** assert properties ***********************************/

    ///////////////////////
    ////              ////
    ////    safety   ////
    ////            ////
    ///////////////////

    // write
    ast_state_WRITE_1_to_WRITE_RESP: assert property(p_state_WRITE_1_to_WRITE_RESP);
    ast_state_WRITE_RESP_to_IDLE: assert property(p_state_WRITE_RESP_to_IDLE);
    ast_state_WRITE_1_no_IDLE_READ_1_READ_RESP: assert property(p_state_WRITE_1_no_IDLE_READ_1_READ_RESP);
    ast_state_WRIRE_RESP_no_WRITE_1_READ_1_READ_RESP: assert property(p_state_WRIRE_RESP_no_WRITE_1_READ_1_READ_RESP);
    ast_state_INIT_to_WRITE_1: assert property(p_state_INIT_to_WRITE_1);
    ast_slave_write_response_stable: assert property(p_slave_write_response_stable);

    // read
    ast_state_READ_1_no_IDLE_WRITE_1_WRITE_RESP: assert property(p_state_READ_1_no_IDLE_WRITE_1_WRITE_RESP);
    ast_state_READ_RESP_to_IDLE: assert property(p_state_READ_RESP_to_IDLE);
    ast_state_READ_RESP_no_READ_1_WRITE_1_WRITE_RESP: assert property(p_state_READ_RESP_no_READ_1_WRITE_1_WRITE_RESP);
    ast_state_INIT_to_READ_1: assert property(p_state_INIT_to_READ_1);

    /////////////////////////
    ////                ////
    ////    liveness   ////
    ////              ////
    /////////////////////
    
    // write
    ast_write_addr_handshake: assert property(p_write_addr_handshake);
    ast_write_data_handshake: assert property(p_write_data_handshake);
    ast_write_response_handshake: assert property(p_write_response_handshake);
    ast_slave_write_response_assertion: assert property(p_slave_write_response_assertion);

    // read
    ast_read_addr_handshake: assert property(p_read_addr_handshake);
    ast_read_response_handshake: assert property(p_read_response_handshake);
    ast_state_READ_1_to_READ_RESP: assert property(p_state_READ_1_to_READ_RESP);
    ast_slave_read_response_stable: assert property(p_slave_read_response_stable);
    ast_slave_read_data_stable: assert property(p_slave_read_data_stable);
    ast_slave_read_response_assertion: assert property(p_slave_read_response_assertion);


endmodule
